    #!/usr/bin/env python3
# -*- coding: utf-8 -*-
"""
Created on Thu Apr  6 15:08:05 2017

This module is made to give easy acccess to the GEO data and project them onto
rectangular longitude-latitude grids. The data are used in their native geometry
from netcdf files.
At the moment (MAy 2017), this module can be used for Himawari (2km files) and the MSG satellites.

Functions:
- read the satellite channels
- perform zenith angle correction on the 10.8Âµm channel using the method of Joyce (contained in a
separate module)
- project onto a set of predefined rectangular grids in longitude-latitude
- make nice charts on these grids
- interpolate in time between two satellite time slot (based on nominal time)
- define a daughter grid that is a subset of one of the predefined grids and extract the fields on this grid
- patch images from two GEO at a given longitude onto a grid

The module relies on a number of external files that define lat-lon satellite grids, mask of the earth disk
in the native satellite geometry, and lookup table for the projections. The lat-lon and mask data are generated
outside this module. The lookup table are generated by the module, once for ever, for each association of
a grid with a GEO.

TO DO: usage doc
Look in the test-geosat directory for examples of usages

@author: Bernard Legras
"""
from netCDF4 import Dataset
import numpy as np
from datetime import datetime
#import tables
import socket
import os
import glob
import copy
import pickle,gzip
from scipy.interpolate import NearestNDInterpolator
#from mpl_toolkits.basemap import Basemap
#from cartopy import feature
#from cartopy.mpl.gridliner import LONGITUDE_FORMATTER, LATITUDE_FORMATTER
import cartopy.crs as ccrs
import matplotlib.pyplot as plt
import sza_correc

# Defines data directories
# To be replaced by your own environment variables
# Notice: sats_dir and gridsat not used in the module
#         alt_root_dir used in the derived module SAFNWCnc for SAFBox
if socket.gethostname() == 'Mentat':
    sats_dir = 'C:\\cygwin64\\home\\berna\\data\\sats'
    root_dir = 'C:\\cygwin64\\home\\berna\\data\\sats'
    alt_root_dir = root_dir
    gridsat = 'C:\\cygwin64\\home\\berna\\data\\sats\\gridsat'
elif 'spirit' in socket.gethostname():
    sats_dir = '/data/legras/sats'
    #root_dir = '/bdd/STRATOCLIM/data'
    root_dir = '/data/legras/sats'
    alt_root_dir = '/data/legras/flexpart_in/SAFNWC'
    gridsat = '/bdd/FCDR/GridSat-B1'
elif ('climserv' in socket.gethostname()) | ('polytechnique' in socket.gethostname()):
    sats_dir = '/data/legras/sats'
    root_dir = '/bdd/STRATOCLIM/data'
    alt_root_dir = '/data/legras/flexpart_in/SAFNWC'
    gridsat = '/bdd/FCDR/GridSat-B1'
elif socket.gethostname() == 'satie':
    sats_dir = '/limbo/data/STC/sats'
    root_dir = '/limbo/data/STC/sats'
    alt_root_dir = root_dir
    gridsat =  '/limbo/data/STC/sats/gridsat'
elif socket.gethostname() in ['grapelli','couperin','zappa','coltrane','puccini']:
    sats_dir = '/net/satie/limbo/data/STC/sats'
    root_dir = '/net/satie/limbo/data/STC/sats'
    alt_root_dir = root_dir
    gridsat =  '/net/satie/limbo/data/STC/sats'
elif socket.gethostname() == 'gort':
    sats_dir = '/dkol/data/STC/sats'
    root_dir = '/dkol/data/STC/sats'
    alt_root_dir = root_dir
    gridsat =  '/dkol/data/STC/sats/gridsat'
elif 'icare' in socket.gethostname():
    sats_dir = '/scratch/b.legras/SAFNWC'
    root_dir = '/scratch/b.legras/sats'
    alt_root_dir = root_dir
    gridsat = 'undefined'
else:
    print ('geosat CANNOT RECOGNIZE HOST - DO NOT RUN ON NON DEFINED HOSTS')

# This mask is made to palliate the incomplete masking of himawari data
# and the supposedly moving mask of MSG satellites
mask_sat={}
lonlat_sat={}

RGB = ('Ash','Dust')

# Read the masks used for the image read by this package
# The masks are defined in the STC/sats subdirectories
def read_mask_himawari():
    mask_sat['himawari'] = pickle.load(gzip.open(os.path.join(root_dir,'himawari','mask.pkl'),'rb'))
def read_mask_MSG():
    # change after 14/05/2017: use the mask based on the data and not that from the lonlat file
    mask_sat['msg'] = pickle.load(gzip.open(os.path.join(root_dir,'msg1','mask.pkl'),'rb'))
def read_mask_GOES():
    mask_sat['goes'] = pickle.load(gzip.open(os.path.join(root_dir,'goesw','mask.pkl'),'rb'))
    print('read goes mask')
# Read the satellite lonlat file to generate the projection
# The longitude are in the [-180,180] interval for GOESE, MSG0 & MSG1
# and in the [0,360] for HIMAWARI and GOESW
def read_lonlat(sat):
    if sat == 'msg1':
        satin = 'msg0'
    else:
        satin = sat
    lonlat_sat[sat] = pickle.load(gzip.open(os.path.join(root_dir,satin,'lonlat.pkl'),'rb'))
    # The msg1 longitudes are derived from the msg3 longitudes by +41.5 offset
    if sat == 'msg1':
       lonlat_sat[sat]['lon'] += 41.5

#%%
class PureSat(object):
    ''' mother class of GeoSat that allows to define derived objects from
    data read with GeoSat class
    '''
    def __init__(self,sat):
        self.var={}
        self.attr={}
        self.fill_value={}
        self.sat = sat

    def show(self,field,clim=[190.,300.],txt='',cmap=None):
        ''' Shows the field in the satellite geometry '''
        if field not in self.var:
            print('undefined field')
            return
        fig = plt.figure()
        iax=plt.imshow(self.var[field],clim=clim,cmap=cmap)
        cax = fig.add_axes([0.91, 0.15, 0.03, 0.7])
        fig.colorbar(iax, cax=cax)
        fig.suptitle(txt)
        plt.show()

    def provide_1D(self,var):
        ''' Returns a compressed 1D field from a masked array
        '''
        return self.var[var].compressed()

    def _sza_correc(self):
        ''' Correction of the brightness temperature of the IR0 channel.
        '''
        print ('entering correction PureSat version')
        if 'IR0' not in self.var.keys():
            print ('IR0 must be defined')
            return
        try:
            sat = self.sat
        except:
            print ('sat non defined')
            return

        if sat not in lonlat_sat.keys():
            read_lonlat(sat)

        sza,_ = sza_correc.szacorr(self.date,self.var['IR0'].flatten(),
                    lonlat_sat[sat]['lon'].flatten(),lonlat_sat[sat]['lat'].flatten(),
                    self.sublon,self.sublat)
        self.var['IR0'] += sza.reshape([self.nlat,self.nlon])
        return

    def _merge(self,other):
       for var in other.var.keys():
           self.var[var] = other.var[var]
       for atr in other.attr.keys():
           self.attr[atr] = other.attr[atr]

class GeoSat(PureSat):
    '''
    Generic parent class to read geostationary netcdf objects.
    Not to be used directly.
    Use product-specific classes instead.
    '''
    def __init__(self, filename):
        '''
        filename : name of the geostationay file
        '''
        try:
            self.ncid = Dataset(filename, mode='r')
        except:
            print('NOT FOUND '+filename)
        # loads the mask if needed
        if ('hima' in filename) & ('himawari' not in mask_sat.keys()):
            read_mask_himawari()
        if ('msg' in filename) & ('msg' not in mask_sat.keys()):
            read_mask_MSG()
        if ('goes' in filename) & ('goes' not in mask_sat.keys()):
            read_mask_GOES()
        try:
            PureSat.__init__(self,self.sat)
        except:
            PureSat.__init__(self,'unknown')
        self.sublon = self.ncid.variables['satellite'].lon
        self.sublat = self.ncid.variables['satellite'].lat
        self.dst = self.ncid.variables['satellite'].dst
        try:
            self.nlon = len(self.ncid.dimensions['nx'])
            self.nlat =len(self.ncid.dimensions['ny'])
        except:
            self.nlon = len(self.ncid.dimensions['nx2km'])
            self.nlat =len(self.ncid.dimensions['ny2km'])

    def close(self):
        self.ncid.close()

    def get_IR0(self):
        ''' Reads the infrared window if not already stored, stores and returns it '''
        if 'IR0' not in self.var.keys():
            self._get_IR0()
        return self.var['IR0']

    def _get_IR0(self):
        '''
        Reads the infrared windows and stores a masked array in self
        '''
        self._get_var('IR0')

    def get_var(self,field):
        ''' Reads a general variable if not already stored, so needed, stores and returns it '''
        if field not in self.var.keys():
            self._get_var(field)
        return self.var[field]

    def _get_var(self,field):
        '''
        Reads a general variable and stores a masked array in self
        '''
        if field in self.channels:
            self.var[field] = np.ma.array(self.ncid.variables[field][:])
            fill_value = self.ncid.variables[field][:].fill_value
        elif field in self.alias_channels:
            self.var[field] = np.ma.array(self.ncid.variables[self.alias_channels[field]][:])
            fill_value = self.ncid.variables[self.alias_channels[field]][:].fill_value
        else:
            print('No field ',field,' on ',self.sat)

        if 'msg' in self.sat:
            self.var[field].__setmask__(mask_sat['msg'])
        elif 'hima' in self.sat:
            self.var[field].__setmask__(mask_sat['himawari'])
        else:
            self.var[field].__setmask__(mask_sat['goes'])
        self.var[field]._sharedmask=False
        try:
            self.fill_value[field] = fill_value
        except:
            self.fill_value[field] = None
        return

    def degrad_IR0(self):
        ''' Makes a new geosat image with averaged total radiance from the estimated brightness temperature
            This is not good and usage should be avoided. The average should be based on the radiance for the IR channel
        '''
        target=PureSat()
        radiance = self.var['IR0']**4
        toto_radiance = 0.5 * (radiance[range(0, radiance.shape[0], 2), :] +
                           radiance[range(1, radiance.shape[0], 2), :])
        target.var['IR0'] = (0.5 * (toto_radiance[:, range(0, toto_radiance.shape[1], 2)] +
                 toto_radiance[:, range(1, toto_radiance.shape[1], 2)])) ** (1. / 4.)
        target.sat = self.sat
        target.sublon = self.sublon
        target.sublat = self.sublat
        target.nlat = target.var['IR0'].shape[0]
        target.nlon = target.var['IR0'].shape[1]
        return target

    def _mk_Ash(self,RGBType='Ash'):
        ''' Generate a variable containing the Eumetsat Ash recipe.
            It read first the needed channels IR0, IR120, IR85 if they are not available.
        '''
        for var in ['IR0','IR120','IR85']:
            if var in self.var.keys(): pass
            elif self.alias_channels[var] in self.var.keys():
                self.var[var] = self.var[self.alias_channels[var]]
            else: self._get_var(var)
        if RGBType == 'Ash':
            clim0 = (243,303)
            clim1 = (-4,5)
            clim2 = (-4,2)
        elif RGBType == 'Dust':
            clim0 = (261,289)
            clim1 = (0,15)
            clim2 = (-4,2)

        DBT1 = self.var['IR0']-self.var['IR85']
        DBT2 = self.var['IR120']-self.var['IR0']

        # rescaling and clipping
        B = np.ma.clip((self.var['IR0']-clim0[0])/(clim0[1]-clim0[0]),0,1)
        G = np.ma.clip((DBT1-clim1[0])/(clim1[1]-clim1[0]),0,1)
        if RGBType == 'Dust':
            G = G**0.4
        R = np.ma.clip((DBT2-clim2[0])/(clim2[1]-clim2[0]),0,1)

        self.var[RGBType] = np.ma.dstack([R,G,B])
        # in order to set the masjked pixels to white color
        self.var[RGBType].data[self.var[RGBType].mask] = 1
        return


#%%
class MSG(GeoSat):
    ''' Specific code for MSG SEVIRI instruments.
        MSG scans from south to north in 715 s.
        MSG longitudes in (-180,180] range
    '''
    def __init__(self, filename):
        GeoSat.__init__(self,filename)
        self.channels = ('IR_016','IR_039','IR_087','IR_097','IR_108','IR_120','IR_134',
                         'VIS_006','VIS_008','WV_062','WV_073')
        self.alias_channels= {'IR0':'IR_108','IR120':'IR_120','IR85':'IR_087',
                                  'WV1':'WV_062','WV2':'WV_073','VIS6':'VIS_006','VIS8':'VIS_008'}

class MSG1(MSG):
    ''' Specific code for MSG1 '''
    def __init__(self,date):
        self.sat = 'msg1'
        self.date =  date
        file = 'Imultic3kmNC4_msg01_' + date.strftime("%Y%m%d%H%M") + '.nc'
        fullname = os.path.join(root_dir, 'msg1', 'netcdf',
                date.strftime("%Y"), date.strftime("%Y_%m_%d"),file)
        MSG.__init__(self,fullname)
        
class MSG2(MSG):
    ''' Specific code for MSG2 '''
    def __init__(self,date):
        self.sat = 'msg2'
        self.date =  date
        file = 'Imultic3kmNC4_msg02_' + date.strftime("%Y%m%d%H%M") + '.nc'
        fullname = os.path.join(root_dir, 'msg2', 'netcdf',
                date.strftime("%Y"), date.strftime("%Y_%m_%d"),file)
        MSG.__init__(self,fullname)

class MSG0(MSG):
    ''' Specific code for MSG0 '''
    def __init__(self,date):
        self.sat='msg0'
        self.date =  date
        # what follows need to be improved with a while or for construction
        file = 'Mmultic3kmNC4_msg0?_' + date.strftime("%Y%m%d%H%M") + '.nc'
        temp_fullname = os.path.join(root_dir, 'msg0', 'netcdf',
                date.strftime("%Y"), date.strftime("%Y_%m_%d"),file)
        try:
            fullname = glob.glob(temp_fullname)[0]
        except IndexError:
            print('NOT FOUND ',temp_fullname)
        MSG.__init__(self,fullname)

#%%
class Himawari(GeoSat):
    ''' Specific code for Himawari.
        Himawari scans from north to south in 558 s.
    '''
    def __init__(self,date):
        self.sat = 'himawari'
        self.date =  date
        #self.file = 'Jmultic2kmNC4_hima0?_' + date.strftime("%Y%m%d%H%M") + '.nc'
        file = 'Jmultic2kmNC4_hima0?_' + date.strftime("%Y%m%d%H%M") + '.nc'
        #self.fullname = os.path.join(root_dir, 'himawari', 'netcdf',
        #        date.strftime("%Y"), date.strftime("%Y_%m_%d"),self.file)
        temp_fullname = os.path.join(root_dir, 'himawari', 'netcdf',
                   date.strftime("%Y"), date.strftime("%Y_%m_%d"),file)
        try:
            self.fullname = glob.glob(temp_fullname)[0]
        except IndexError:
            print('NOT FOUND ',temp_fullname)        
        self.channels = ('IR_016','IR_022','IR_038','IR_085','IR_096','IR_104','IR_112','IR_123','IR_132',
                     'VIS004','VIS005','VIS006','VIS008','WV_062','WV_069','WV_073')
        self.alias_channels= {'IR0':'IR_104','IR120':'IR_123','IR85':'IR_085',
                              'WV1':'WV_062','WV2':'WV_073','VIS6':'VIS006','VIS8':'VIS008'}
        GeoSat.__init__(self,self.fullname)

#%%
class GOES(GeoSat):
    ''' Specific code for MSG SEVIRI instruments
        GOES scans from north to south in 571 s.
    '''
    def __init__(self, filename):
        GeoSat.__init__(self,filename)
        self.channels = ('IR_039','IR_062','IR_069','IR_073','IR_085','IR_096','IR_103','IR_112','IR_123','IR_133',
                         'VIS_004','VIS_006','VIS_008','VIS_014','VIS_016','VIS_O22')
        self.alias_channels= {'IR0':'IR_103','IR120':'IR_123','IR85':'IR_085',
                                  'WV1':'IR_062','WV2':'IR_073','VIS6':'VIS_006','VIS8':'VIS_008'}

class GOESW(GOES):
    ''' Specific code for GOESW '''
    def __init__(self,date):
        self.sat = 'goesw'
        self.date =  date
        
        file = 'Wmultic2kmNC4_goes1?_' + date.strftime("%Y%m%d%H%M") + '.nc'
        temp_fullname = os.path.join(root_dir, 'goesw', 'netcdf',
                date.strftime("%Y"), date.strftime("%Y_%m_%d"),file)
        try:
            fullname = glob.glob(temp_fullname)[0]
        except IndexError:
            print('NOT FOUND ',temp_fullname)
        GOES.__init__(self,fullname)

class GOESE(GOES):
    ''' Specific code for GOESE '''
    def __init__(self,date):
        self.sat='goese'
        self.date =  date
        if date > datetime(2017,12,14,16):
            file = 'Emultic2kmNC4_goes1?_' + date.strftime("%Y%m%d%H%M") + '.nc'
            temp_fullname = os.path.join(root_dir, 'goese', 'netcdf',
                date.strftime("%Y"), date.strftime("%Y_%m_%d"),file)
        else:
            self.sat='goesefg'
            file = 'Emultic4kmNC4_goes1?_' + date.strftime("%Y%m%d%H%M") + '.nc'
            temp_fullname = os.path.join(root_dir, 'goesefg', 'netcdf',
                date.strftime("%Y"), date.strftime("%Y_%m_%d"),file)
        try:
            fullname = glob.glob(temp_fullname)[0]
        except IndexError:
            print('NOT FOUND ',temp_fullname)
        GOES.__init__(self,fullname)

#%%
class GeoGrid(object):
    '''
    Defines the attributes of the grid.
    The regular latxlongrids are defined by a bounding box and
    the number of meshes in latitude and longitudes.
    The edges and the centers are then calculated. The projection
    is based on the centers, thus assuming that the satellite grids
    are also based on pixel centers.
    '''
    def __init__(self, gridtype,box=None,bins=None):
        self.gridtype = gridtype
        if gridtype == "FullAMA":
            self.box_range = np.array([[-10.,160.], [0.,50.]])
            self.box_binx = 1700; self.box_biny = 500
        elif gridtype == "FullAMA_SAFBox":
            self.box_range = np.array([[-10.,160.], [0.,50.]])
            self.box_binx = 1700; self.box_biny = 500
        elif gridtype == "ACCLIP":
            self.box_range = np.array([[-10.,240.], [0.,60.]])
            self.box_binx = 2500; self.box_biny = 600
        elif gridtype == "ACCLIP-Houston":
            self.box_range = np.array([[160.,350.], [0.,60.]])
            self.box_binx = 1900; self.box_biny = 600
        elif gridtype == "HimFull":
            self.box_range = np.array([[60.,220.],[-80.,80.]])
            self.box_binx = 4000; self.box_biny = 4000;
        elif gridtype == "MSG1Full":
            self.box_range = np.array([[-38.5,121.5],[-80,80]])
            self.box_binx = 4000; self.box_biny = 4000;
        elif gridtype == "MSG2Full":
            self.box_range = np.array([[-34.5,117.5],[-80,80]])
            self.box_binx = 4000; self.box_biny = 4000;
        elif gridtype == "MSG0Full":
            self.box_range = np.array([[-80,80],[-80,80]])
            self.box_binx = 4000; self.box_biny = 4000;
        elif gridtype == "GOESEFull":
            self.box_range = np.array([[-155,5],[-80,80]])
            self.box_binx = 4000; self.box_biny = 4000;
        elif gridtype == "GOESWFull":
            self.box_range = np.array([[143,303],[-80,80]])
            self.box_binx = 4000; self.box_biny = 4000;
        elif gridtype == "LatBand1":
            self.box_range = np.array([[-180,180.01],[-35,10]])
            self.box_binx = 3600; self.box_biny = 450;
        elif gridtype == "LatBand2":
            self.box_range = np.array([[-160,200.01],[-35,10]])
            self.box_binx = 3600; self.box_biny = 450;
        elif gridtype == "NAG":
            self.box_range = np.array([[67.5,91.5],[9.,33.]])
            self.box_binx = 240; self.box_biny = 240;
        elif gridtype == "KTM":
            self.box_range = np.array([[73.,97.],[15.,39.]])
            self.box_binx = 240; self.box_biny = 240;
        elif gridtype == "KLM":
            self.box_range = np.array([[10.,35.],[25.,45.]])
            self.box_binx = 200; self.box_biny = 200;
        elif gridtype == "MesoMed":
            self.box_range = np.array([[-10.,50.],[20.,45.]])
            self.box_binx = 600; self.box_biny = 250;
        elif gridtype == "MesoInd":
            self.box_range = np.array([[65.,130.],[5.,40.]])
            self.box_binx = 650; self.box_biny = 350;
        elif gridtype == "Canada":
            self.box_range = np.array([[-130.,-50.],[40,70]])
            self.box_binx = 800; self.box_biny = 300;
        elif gridtype == "Australia":
            self.box_range = np.array([[105.,160.],[-40,-10]])
            self.box_binx = 550; self.box_biny = 300;
        elif gridtype == "Bolivar":
            self.box_range = np.array([[-80.,-40.],[-30,0]])
            self.box_binx = 400; self.box_biny = 300;
        elif gridtype == "GridSat":
            """ pixels of 0.07 degree slightly overmatch at the
                last longitude since 0.07 is not a divider of 360.
                Notice however that the gridsat FAQ indicates that
                lat lon are centered but this contradicts somewhat
                starting in lat at -70 and ending at 69.93,
                not being symmetric.
            """
            self.box_range = np.array([[-180.,180.01],[-70.,70.]])
            self.box_binx = 5143; self.box_biny = 2000;
        else:
            if bins==None:
                print("Unknown gridtype")
                raise NameError
            else:
                self.gridtype = gridtype
                self.box_range = np.array(box)
                self.box_binx = bins[0]
                self.box_biny = bins[1]
        # derived grid properties
        self.xedge = np.arange(self.box_range[0,0], self.box_range[0,1]+0.001,
                   (self.box_range[0,1]-self.box_range[0,0])/self.box_binx)
        self.yedge = np.arange(self.box_range[1,0], self.box_range[1,1]+0.001,
                   (self.box_range[1,1]-self.box_range[1,0])/self.box_biny)
        self.xcent = 0.5*(self.xedge[range(0, len(self.xedge)-1)]+self.xedge[range(1, len(self.xedge))])
        self.ycent = 0.5*(self.yedge[range(0, len(self.yedge)-1)]+self.yedge[range(1, len(self.yedge))])
        self.shapeyx = [len(self.ycent),len(self.xcent)]
        self.shapexy = [len(self.xcent),len(self.ycent)]
        self.stepx = (self.box_range[0,1]-self.box_range[0,0])/self.box_binx
        self.stepy = (self.box_range[1,1]-self.box_range[1,0])/self.box_biny
        return

    def subgrid(self,bounds):
        ''' Generates a subgrid with name temp that is a daughter of the main
        and can be used to make plots in a subdomain using standard plot'''
        try:
            [Lo1,Lo2,La1,La2] = bounds
        except:
            print ("badly shaped box")
        # first check that the boundaries are within the mother grid
        if (Lo1 > self.box_range[0,1]) | (Lo1 < self.box_range[0,0]):
            print ('Lo1 outside bounds')
        if (Lo2 > self.box_range[0,1]) | (Lo2 < self.box_range[0,0]):
            print ('Lo2 outside bounds')
        if (La1 > self.box_range[1,1]) | (La1 < self.box_range[1,0]):
            print ('La1 outside bounds')
        if (La2 > self.box_range[1,1]) | (La2 < self.box_range[1,0]):
            print ('La2 outside bounds')
        # find boundaries as nearest neigbours in the mother grid
        eps=0.0001
        lowlon = np.where(self.xedge-Lo1-eps<=0)[0][-1]
        higlon = np.where(self.xedge-Lo2+eps>=0)[0][0]
        lowlat = np.where(self.yedge-La1-eps<=0)[0][-1]
        higlat = np.where(self.yedge-La2+eps>=0)[0][0]
        print(lowlon,higlon,lowlat,higlat)
        # create new object
        other = GeoGrid("temp",box=np.array([[self.xedge[lowlon],self.xedge[higlon]],
                                    [self.yedge[lowlat],self.yedge[higlat]]]),
                                    bins =[higlon-lowlon,higlat-lowlat])
        other.mothergrid = self.gridtype
        other.corner = [lowlon,lowlat]
        return other

    def _mkandsav_lookup(self,sat,BB=None,BBname='',dist=False):
        ''' Generates the lookup table for a pair sat and grid.
        Usage: first generate the grid object
               gg = geosat.GeoGrid(gridtype)
               where gridtype is one of the allowed grids
               then runs the generator for this grid and a given satellite
               (it takes a while)
               gg._mkandsav_lookup(sat)
               sat can take values among himawari, msg1, msg3
               BB is a bounding box in the following format [lat1,lat2,lon1,lon2]
               lat1 and lat2 are the first and the last latitude retained
               lon1 and lon2 are the first and the last longitude retained
               BBname is a box name used to build the name of the output file
               This option is useful if the input results from the processsing
               of a part of the satellite images.
        Very important point: The lonlat file must be a masked array equipped
               with the same mask that will be used for all the images of the satellite.
               Failure to enforce strictly this rule will generate irrecoverable
               errors. For MSG and Hiamawari, this mask is read in read_mask_MSG and
               read_mask_himawari. It is not read here but it is assumed that lonlat.pkl
               has been generated with it.
               TO DO: add a check here that read the mask and compares it to that in the lonlat.pkl
               file to be sure they match.

        For Full_AMA_SAF: msg1:     BB = [340,1856,306,3350]
                          himawari: BB = [474,2750,444,3793]
        '''
        # get the lon lat grid from the satellite
        try:
            if sat == 'msg1':
                satin = 'msg0'
            elif sat == 'msg2':
                satin = 'msg0'
            else:
                satin = sat
            print(os.path.join(root_dir,satin,'lonlat.pkl'))
            lonlat = pickle.load(gzip.open(os.path.join(root_dir,satin,'lonlat.pkl'),'rb'))
            # add 360 to avoid discontinuity at 180 for Himawari
            if sat == 'himawari':
                lonlat['lon'][lonlat['lon']<0] += 360
            # add 41.5 degree to msg3 lon to get msg1 lon
            if sat == 'msg1':
                lonlat['lon'] += 41.5
            elif sat == 'msg2':
                lonlat['lon'] += 45.5
            
            # extract the bounding box if required
            #
            if BB is not None:
                try:
                    print ('reduction of lonlat')
                    lonlat['lon'] = lonlat['lon'][BB[0]:BB[1]+1,BB[2]:BB[3]+1]
                    lonlat['lat'] = lonlat['lat'][BB[0]:BB[1]+1,BB[2]:BB[3]+1]
                    lonlat['BB'] = BB        
                except:
                    print('ERROR WHILE BOUNDING THE LATITUDE AND LONGITUDE GRIDS, CHECK BB')
                    return
            # Flatten the grid and select only the non masked pixels
            lonlat_c = np.asarray([lonlat['lon'].compressed(), lonlat['lat'].compressed()])
        except:
            print ('sat or lonlat undefined')
            return
        # Calculate interpolator index
        idx = np.arange(lonlat_c.shape[1], dtype=int)
        print('NearestNDInterpolator start')
        interp = NearestNDInterpolator(lonlat_c.T,idx)
        print('NearestNDInterpolator done')
        # Building the lookup table for the grid
        # self.xcent must not be modified, hence the modification on a copy
        if ('LatBand' in self.gridtype) & (sat in ('himawari','goesw')):
            xcent = copy.copy(self.xcent)
            xcent = xcent%360
        elif (self.gridtype == 'ACCLIP-Houston') & (sat == 'goese'):
            xcent = copy.copy(self.xcent)
            xcent -= 360
        #elif (self.gridtype == 'ACCLIP_Houston') & (sat == 'goesw'):
        #    xcent = copy.copy(self.xcent)
        #    xcent[xcent>=180] -= 360
        else:
            xcent = self.xcent
        lookup = np.empty(shape=(len(self.ycent),len(xcent)), dtype=int)
        for j in range(len(self.ycent)):
            lookup[j,:] = interp(np.asarray([xcent,np.repeat(self.ycent[j],len(xcent))]).T)
        self.lookup_dict={}
        self.lookup_dist={}
        self.lookup_dict['lat_g']=self.ycent
        self.lookup_dict['lon_g']=self.xcent
        self.lookup_dict['lookup_f']=lookup.flatten()
        # Calculate actual distances between pixels on the regular grid and the
        # closest neighbour on the Himawari grid that can be used to generate a
        # mask to disclose meshes which are too far from their nearest neighbour
        # distance is in a regular lon lat space
        self.lookup_dist['distx']=abs(np.repeat([xcent],len(self.ycent),axis=0).flatten()-(lonlat['lon'].compressed())[self.lookup_dict['lookup_f']])
        self.lookup_dist['disty']=abs((np.repeat([self.ycent],len(xcent),axis=0).T).flatten()-(lonlat['lat'].compressed())[self.lookup_dict['lookup_f']])
        # Calculate a mask with distance less than 0.2 in longitude or latitude
        offset=0.2
        self.lookup_dict['mask']=(self.lookup_dist['distx']>offset) | (self.lookup_dist['disty']>offset)
        # Add lonlat mask to the dist as this is useful to process the data (highly compressible)
        #self.lookup_dict['in_mask'] = lonlat['lon'].mask
        # Store the lookup table and distances separately
        if BBname != '':
            BBname = '_'+BBname
        pickle.dump(self.lookup_dict,gzip.open(os.path.join(root_dir,sat,
              'lookup_'+sat+'_'+self.gridtype+BBname+'.pkl'),'wb',pickle.HIGHEST_PROTOCOL))
        if dist: pickle.dump(self.lookup_dist,gzip.open(os.path.join(root_dir,sat,
              'lookup_dist_'+sat+'_'+self.gridtype+BBname+'.pkl'),'wb',pickle.HIGHEST_PROTOCOL))

#%%
class GridField(object):
    '''
    Data object on a grid. Expect a valid GeoGrid object as argument
    '''
    def __init__(self, geogrid):
        try:
            self.geogrid = geogrid
            self.gridtype = geogrid.gridtype
        except:
            print ('geogrid object basdly defined')
            return
        # Initializes var dictionary
        self.var={}

    def chart(self,field,cmap='jet',clim=[190.,300.],txt='',subgrid=None, block=True, xlocs=None, figsize= None,
              axf=None, show=True, cm_lon=None,left=True,bottom=True, xlim=None, pos_cax=None):
        # test existence of key field
        if field not in self.var.keys():
            print ('undefined field')
            return
        fs = 15
        if subgrid == None:
            geogrid = self.geogrid
        else:
            geogrid = subgrid
        if axf is None:
            if 'FullAMA' in geogrid.gridtype:
                fig = plt.figure(figsize=[10, 6])
            elif figsize is not None:
                fig = plt.figure(figsize=figsize)
            else:
                fig = plt.figure(figsize=[11,4])
            fig.subplots_adjust(hspace=0,wspace=0.5,top=0.925,left=0.)

            # it is unclear how the trick with cm_lon works in imshow but it does
            # the web says that it is tricky to plot data accross dateline with cartopy
            # check https://stackoverflow.com/questions/47335851/issue-w-image-crossing-dateline-in-imshow-cartopy
            if cm_lon is None:
                cm_lon =0
                # guess that we want to plot accross dateline
                if geogrid.box_range[0,1]> 181: cm_lon = 0.5*(geogrid.box_range[0,0]+geogrid.box_range[0,1])
                if 'LatBand2' in geogrid.gridtype: cm_lon = 20
            proj = ccrs.PlateCarree(central_longitude=cm_lon)
            ax = plt.axes(projection = proj)
            if 'LatBand2' in geogrid.gridtype:
                ax.set_extent([-160,199.9, -35,10], crs=ccrs.PlateCarree())
            else:
                ax.set_extent(geogrid.box_range.flatten()-np.array([cm_lon,cm_lon,0,0]), crs=ccrs.PlateCarree())
        else:
            ax = axf
            if cm_lon == None:
                print('cm_lon should be defined')
                return -1
            show = False
        # guess that we want to plot accross dateline

        if subgrid == None:
            plotted_field = self.var[field]
        else:
            # extraction in subgrid
            plotted_field = self.var[field][geogrid.corner[1]:geogrid.corner[1]+geogrid.box_biny,
                                            geogrid.corner[0]:geogrid.corner[0]+geogrid.box_binx]
        if 'LatBand2' in geogrid.gridtype:
            iax = ax.imshow(plotted_field, transform=ax.projection, interpolation='nearest',
                    extent=[-160-cm_lon,199.99-cm_lon, -35,10],
                    origin='lower', aspect=1.,cmap=cmap,clim=clim)
        else:
            iax = ax.imshow(plotted_field, transform=ax.projection, interpolation='nearest',
                    extent=geogrid.box_range.flatten()-np.array([cm_lon,cm_lon,0,0]),
                    origin='lower', aspect=1.,cmap=cmap,clim=clim)
        # ax.add_feature(feature.NaturalEarthFeature(
        #     category='cultural',
        #     name='admin_1_states_provinces_lines',
        #     scale='50m',
        #     facecolor='none'))
        ax.coastlines('50m')
        #ax.add_feature(feature.BORDERS)
        # The grid adjusts automatically with the following lines
        # If crossing the dateline, superimposition of labels there
        # can be suppressed by specifying xlocs

        if (cm_lon == 180) & (xlocs == None): xlocs = [0,30,60,90,120,150,180,-150,-120,-90,-60,-30]
        xlocs = None
        gl = ax.gridlines(draw_labels=True, xlocs=xlocs,
                      linewidth=2, color='gray', alpha=0.5, linestyle='--')
        gl.top_labels = False
        gl.right_labels = False
        if not left: gl.left_labels = False
        if not bottom: gl.bottom_labels = False
        #gl.xformatter = LONGITUDE_FORMATTER
        #gl.yformatter = LATITUDE_FORMATTER
        gl.xlabel_style = {'size': fs}
        gl.ylabel_style = {'size': fs}
        #gl.xlabel_style = {'color': 'red', 'weight': 'bold'}
        ax.set_title(txt,fontsize=fs)
        if xlim is not None: ax.set_xlim(xlim[0], xlim[1])
        else: ax.set_xlim(geogrid.box_range[0,0]-cm_lon, geogrid.box_range[0,1]-cm_lon)
        
        # plot adjusted colorbar and show
        if field not in RGB:
            axpos = ax.get_position()
            pos_x = axpos.x0 + axpos.x0 + axpos.width + 0.01
            if pos_cax == None:
                pos_cax = ax.figure.add_axes([pos_x,axpos.y0,0.04,axpos.height])          
            cbar = plt.colorbar(iax,cax=pos_cax)           
            cbar.ax.tick_params(labelsize=fs)
        if show: plt.show(block=block)
        return ax

    def patch(self,other,lon,var):
        ''' Patch two fields on the same grid at a given longitude given by lon.
        Self is on the left of the other
        '''
        if self.gridtype != other.gridtype:
            print('error: grids do not match')
            return -1
        patched = GridField(self.geogrid)
        patching_x = np.where(self.geogrid.xcent > lon)[0][0]
        # Add here processing of lonmax
        if type(var) == str:
            var1 = [var,]
        else:
            var1 = var
        for vv in var1:
            if var in RGB:
                patched.var[vv] = np.ma.concatenate([self.var[vv][:,:patching_x,:],other.var[vv][:,patching_x:,:]],axis=1)
            else:
                patched.var[vv] = np.ma.concatenate([self.var[vv][:,:patching_x],other.var[vv][:,patching_x:]],axis=1)
        return patched

    def _filt(self,var,threshold,sign='equal'):
        if sign == 'equal':
            #np.ma.masked_values(self.var[var], threshold, copy=False)
            self.var[var][self.var[var] == threshold] = np.ma.masked
        elif sign == 'less':
            #np.ma.masked_less(self.var[var], threshold, copy=False)
            self.var[var][self.var[var] < threshold] = np.ma.masked
        elif sign == 'more':
            #np.ma.masked_greater(self.var[var], threshold, copy=False)
            self.var[var][self.var[var] > threshold] = np.ma.masked
#%%
class GridSat(GridField):
    ''' Class for GridSat data '''

    def __init__(self,date):
        self.sat = 'GridSat'
        self.date = date
        self.var = {}
        self.file = os.path.join(gridsat,date.strftime('%Y'),date.strftime('GRIDSAT-B1.%Y.%m.%d.%H.v02r01.nc'))
        try:
            self.ncid = Dataset(self.file,mode='r')
        except:
            print('cannot open ',self.file)
            return None
        self.geogrid = GeoGrid('GridSat')
        self.convert_GridSat = {'IR0':'irwin_cdr','WV67':'irwvp','IR2':'irwin_2'}
        GridField.__init__(self,self.geogrid)

    def _get_var(self,var):
        try:
            var_file = self.convert_GridSat[var]
        except:
            var_file = var
        self.var[var] = np.ma.array(self.ncid.variables[var_file][0,...].data,
                fill_value = self.ncid.variables[var_file].missing_value)
        self.var[var][self.var[var]==self.ncid.variables[var_file].missing_value] = np.ma.masked
        self.var[var] *= self.ncid.variables[var_file].scale_factor
        self.var[var] += self.ncid.variables[var_file].add_offset

    def _get_IR0(self):
        self._get_var('IR0')

    def _get_WV67(self):
       self._get_var('WV67')

    def close(self):
        self.ncid.close()


#%%
class SatGrid(GridField):
    ''' Associates a geosat object to a grid, both being predefined '''
    def __init__(self, geosat, geogrid):
        try:
            GridField.__init__(self,geogrid)
            self.geosat = geosat
            self.sat = geosat.sat
            self.cname = self.sat + '_' + self.gridtype
        except:
            print ('geosat object basdly defined')
            return
        global lookup, lookup_dist
        try:
            if self.cname not in lookup.keys():
                raise NameError
        except:
            # try to load the lookup table
            if 'lookup' not in globals():
                lookup = {}
                #lookup_dist = {}
            try:
                lookup[self.cname]=pickle.load(gzip.open(os.path.join(root_dir,self.sat,'lookup_'+self.cname+'.pkl'),'rb'))
                #lookup_dist[self.cname]=pickle.load(gzip.open(os.path.join(root_dir,self.sat,'lookup_dist_'+self.cname+'.pkl'),'rb'))
                print('lookup table loaded for ',self.cname)
            except:
                print ('Lookup table for this grid and sat does not exist yet.')
                print ('Must be done prior to creation of this object.' )

#%%
    def _sat_togrid(self,field,clean=True):
        ''' Conversion to the grid using lookup table
        If the parameter clean is set, the data with fill_value are masked'''
        # check that the field has been read
        if field not in self.geosat.var.keys():
            print ('field ',field,' must be read before conversion to grid')
            return
        # doing the conversion and setting the mask of the data which cannot be defined in
        # the target grid
        if field in RGB:
            self.var[field] = np.ma.dstack([
                np.ma.array(self.geosat.var[field][...,0].compressed()[lookup[self.cname]['lookup_f']].reshape(self.geogrid.shapeyx)),
                np.ma.array(self.geosat.var[field][...,1].compressed()[lookup[self.cname]['lookup_f']].reshape(self.geogrid.shapeyx)),
                np.ma.array(self.geosat.var[field][...,2].compressed()[lookup[self.cname]['lookup_f']].reshape(self.geogrid.shapeyx)),
                ])
            buf = lookup[self.cname]['mask'].reshape(self.geogrid.shapeyx)
            self.var[field].__setmask__(np.dstack([buf,buf,buf]))
            self.var[field].data[self.var[field].mask] = 1
        else:
            self.var[field] = np.ma.array(self.geosat.var[field].compressed()[lookup[self.cname]['lookup_f']].reshape(self.geogrid.shapeyx))
            self.var[field].__setmask__(lookup[self.cname]['mask'].reshape(self.geogrid.shapeyx))
        self.var[field]._sharedmask=False
        try:
            self.fill_value = self.geosat.fill_value[field]
        except:
            try:
                self.fill_value = self.geosat.attr[field]['FillValue']
            except:
                self.fill_value = None
        if clean & (self.fill_value != None):
            self.var[field][self.var[field]==self.fill_value] = np.ma.masked
        return

    def _sza_correc(self):
        ''' Correction of the brightness temperature of the IR0 channel using
        the correction described in Joyce (2000).
        '''
        print('entering sza_correction SatGrid version')
        if 'IR0' not in self.var.keys():
            print ('IR0 must be defined')
            return
        # generates repeated lon and lat
        llons = np.repeat([self.geogrid.xcent],len(self.geogrid.ycent),axis=0).flatten()
        llats = (np.repeat([self.geogrid.ycent],len(self.geogrid.xcent),axis=0).T).flatten()
        sza,_ = sza_correc.szacorr(self.geosat.date,self.var['IR0'].flatten(),llons,llats,self.geosat.sublon,self.geosat.sublat)
        self.var['IR0'] += sza.reshape(self.geogrid.shapeyx)
        return
